<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>MARC::Doc::Tutorial - A documentation-only module for new users of MARC::Record</title>
<link rev="made" href="mailto:ed@ink.inkdroid.org" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#introduction">INTRODUCTION</a></li>
	<ul>

		<li><a href="#what_is_marc">What is MARC?</a></li>
		<li><a href="#what_is_this_tutorial">What is this Tutorial?</a></li>
		<li><a href="#history_of_marc_on_cpan">History of MARC on CPAN</a></li>
		<li><a href="#brief_overview_of_marc_classes">Brief Overview of MARC classes</a></li>
		<li><a href="#help_wanted!">Help Wanted!</a></li>
	</ul>

	<li><a href="#reading">READING</a></li>
	<ul>

		<li><a href="#reading_a_record_from_a_file">Reading a record from a file</a></li>
		<li><a href="#iterating_through_a_batch_file">Iterating through a batch file</a></li>
		<li><a href="#checking_for_errors">Checking for errors</a></li>
		<li><a href="#recovering_from_errors">Recovering from errors</a></li>
		<li><a href="#looking_at_a_field">Looking at a field</a></li>
		<li><a href="#looking_at_repeatable_fields">Looking at repeatable fields</a></li>
		<li><a href="#looking_at_a_set_of_related_fields">Looking at a set of related fields</a></li>
		<li><a href="#looking_at_all_the_fields_in_a_record">Looking at all the fields in a record</a></li>
	</ul>

	<li><a href="#creating">CREATING</a></li>
	<ul>

		<li><a href="#creating_a_record">Creating a record</a></li>
		<li><a href="#creating_a_record_from_raw_marc_data_in_a_variable">Creating a record from raw MARC data in a variable</a></li>
	</ul>

	<li><a href="#writing">WRITING</a></li>
	<ul>

		<li><a href="#writing_records_to_a_file">Writing records to a file</a></li>
		<li><a href="#debugging_with_as_formatted()">Debugging with <code>as_formatted()</code></a></li>
		<li><a href="#debugging_with_marcdump()">Debugging with <code>marcdump()</code></a></li>
	</ul>

	<li><a href="#updating">UPDATING</a></li>
	<ul>

		<li><a href="#adding_a_field">Adding a field</a></li>
		<li><a href="#preserving_field_order">Preserving field order</a></li>
		<li><a href="#deleting_a_field">Deleting a field</a></li>
		<li><a href="#changing_existing_fields">Changing existing fields</a></li>
		<li><a href="#updating_subfields_and_indicators">Updating subfields and indicators</a></li>
		<li><a href="#changing_a_record's_leader">Changing a record's leader</a></li>
		<li><a href="#modifying_fields_without_indicators">Modifying fields without indicators</a></li>
		<li><a href="#reordering_subfields">Reordering subfields</a></li>
	</ul>

	<li><a href="#validating">VALIDATING</a></li>
	<ul>

		<li><a href="#using_marc::lint">Using MARC::Lint</a></li>
		<li><a href="#customizing_marc::lint">Customizing MARC::Lint</a></li>
	</ul>

	<li><a href="#swollen_appendices">SWOLLEN APPENDICES</a></li>
	<ul>

		<li><a href="#comparing_collections">Comparing Collections</a></li>
		<li><a href="#authority_records">Authority Records</a></li>
		<li><a href="#urls">URLs</a></li>
		<li><a href="#isbn/issns">ISBN/ISSNs</a></li>
		<li><a href="#call_numbers">Call numbers</a></li>
		<li><a href="#subject_headings">Subject headings</a></li>
		<li><a href="#html">HTML</a></li>
		<li><a href="#xml">XML</a></li>
		<li><a href="#excel">Excel</a></li>
		<li><a href="#databases">Databases</a></li>
		<li><a href="#z39.50">Z39.50</a></li>
		<li><a href="#procite/endnote">Procite/Endnote</a></li>
	</ul>

	<li><a href="#contributors">CONTRIBUTORS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>MARC::Doc::Tutorial - A documentation-only module for new users of MARC::Record</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 perldoc MARC::Doc::Tutorial</pre>
<p>
</p>
<hr />
<h1><a name="introduction">INTRODUCTION</a></h1>
<p>
</p>
<h2><a name="what_is_marc">What is MARC?</a></h2>
<p>The MAchine Readable Cataloging format was designed by the Library of
Congress in the late 1960s in order to allow libraries to convert their card
catalogs into a digital format. The advantages of having computerized card
catalogs were soon realized, and now MARC is being used by all sorts of
libraries around the world to provide computerized access to their collections.
MARC data in transmission format is optimized for processing by computers, so 
it's not very readable for the normal human. For more about the MARC format
visit the Library of Congress at <a href="http://www.loc.gov/marc/">http://www.loc.gov/marc/</a></p>
<p>
</p>
<h2><a name="what_is_this_tutorial">What is this Tutorial?</a></h2>
<p>The document you are reading is a beginners guide to using Perl to processing
MARC data, written in the 'cookbook' style. Inside you will find recipes on 
how to read, write, update and convert MARC data using the MARC::Record CPAN 
package. As with any cookbook you should feel free to dip in at any section
and use the recipe you find interesting. If you are new to Perl you may 
want to read from the beginning.</p>
<p>The document you are reading is distributed with the MARC::Record package, 
however in case you are reading it somewhere else you can find the latest 
version at CPAN <a href="http://www.cpan.org/modules/by-module/MARC/.">http://www.cpan.org/modules/by-module/MARC/.</a></p>
<p>You'll notice that some sections aren't filled in yet, which is a result
of this document being a work in progress. If you have ideas for new sections
please let the make a suggestion on perl4lib <a href="http://www.rice.edu/perl4lib/">http://www.rice.edu/perl4lib/</a></p>
<p>
</p>
<h2><a name="history_of_marc_on_cpan">History of MARC on CPAN</a></h2>
<p>In 1999 a group of developers began working on MARC.pm to provide a Perl 
module for working with MARC data. MARC.pm was quite successful since it 
grew to include many new options that were requested by the Perl/library
community.  However, in adding these features the module swiftly outgrew it's
own clothes, and maintenance and addition of new features became extremely
difficult.</p>
<p>In mid 2001 Andy Lester released MARC::Record and MARC::Field
which provided a much more simpler and maintainable package for processing
MARC data with Perl. Instead of forking the two projects the developers agreed
to encourage use of the MARC::Record framework, and to work on enhancing 
MARC::Record rather than extending MARC.pm further.</p>
<p>
</p>
<h2><a name="brief_overview_of_marc_classes">Brief Overview of MARC classes</a></h2>
<p>The MARC::Record package is made up of several separate packages. This
can be somewhat confusing to people new to Perl, or Object Oriented 
Programming. However this framework allows easy extension, and is built
to support new input/output formats as their need arises. For a good 
introduction to using the object oriented features of Perl see 
the perlboot documentation that came with your version of Perl:</p>
<pre>
 perldoc perlboot</pre>
<p>Here are the packages that get installed when you install the MARC::Record
patch.</p>
<dl>
<dt><strong><a name="item_marc%3a%3arecord">MARC::Record</a></strong><br />
</dt>
<dd>
The primary class, which represents the data held in a MARC record. It is
basically a container class for multiple MARC::Field objects.
</dd>
<p></p>
<dt><strong><a name="item_marc%3a%3afield">MARC::Field</a></strong><br />
</dt>
<dd>
An object for representing the indicators and subfields contained in a 
single MARC field.
</dd>
<p></p>
<dt><strong><a name="item_marc%3a%3abatch">MARC::Batch</a></strong><br />
</dt>
<dd>
A convenience class for accessing MARC data contained in an external file.
</dd>
<p></p>
<dt><strong><a name="item_marc%3a%3afile">MARC::File</a></strong><br />
</dt>
<dd>
A superclass for representing files of MARC data.
</dd>
<p></p>
<dt><strong><a name="item_marc%3a%3afile%3a%3ausmarc">MARC::File::USMARC</a></strong><br />
</dt>
<dd>
A subclass of MARC::File for working with data encoded in the USMARC format.
</dd>
<p></p>
<dt><strong><a name="item_marc%3a%3afile%3a%3amicrolif">MARC::File::MicroLIF</a></strong><br />
</dt>
<dd>
A subclass of MARC::File for working with data encoded in the MicroLIF format.
</dd>
<p></p>
<dt><strong><a name="item_marc%3a%3adoc%3a%3atutorial">MARC::Doc::Tutorial</a></strong><br />
</dt>
<dd>
This document!
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="help_wanted!">Help Wanted!</a></h2>
<p>It's already been mentioned but it's worth mentioning again: 
MARC::Doc::Tutorial is a work in progress, and you are encouraged to submit
any suggestions for additional recipes via the perl4lib listserv 
<a href="http://www.rice.edu/perl4lib">http://www.rice.edu/perl4lib</a> . Also, the development group is always looking 
for additional developers with good ideas, if you are interested you can 
sign up at SourceForge <a href="http://sourceforge.net/projects/marcpm/">http://sourceforge.net/projects/marcpm/</a></p>
<p>
</p>
<hr />
<h1><a name="reading">READING</a></h1>
<p>
</p>
<h2><a name="reading_a_record_from_a_file">Reading a record from a file</a></h2>
<p>Let's say you have a USMARC record in a file called 'file.dat' and you would 
like to read in the record and print out it's title.</p>
<pre>
   1   ## Example 1 
   2   
   3   ## create a MARC::Batch object
   4   use MARC::Batch;
   5   my $batch = MARC::Batch( 'USMARC', 'file.dat');
   6   
   7   ## get a marc record from the MARC::Batch object
   8   ## $record will be a MARC::Record object
   9   my $record = $batch-&gt;next();
  10   
  11   ## print the title contained in the record
  12   print $record-&gt;title(),&quot;\n&quot;;</pre>
<p>
</p>
<h2><a name="iterating_through_a_batch_file">Iterating through a batch file</a></h2>
<p>Now imagine that 'file.dat' actually contains multiple records and 
we want to print out the title for all of them. Our program doesn't have 
to change very much at all: we just need to add a loop around our call
to <code>next()</code>.</p>
<pre>
   1   ## Example 2 
   2   
   3   ## create a MARC::Batch object
   4   use MARC::Batch;
   5   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   6   
   7   while (my $record = $file-&gt;next()) {
   8   
   9     ## print the title contained in the record
  10     print $record-&gt;title(),&quot;\n&quot;;
  11   
  12   }
  13   
  14   ## we're done so close the file
  15   $file-&gt;close();</pre>
<p>The call to the <code>next()</code> method at line 7 returns the next record from the 
file. <code>next()</code> returns <code>undef</code> when there are no more records left in the file,
which causes the while loop to end. This is a useful idiom for reading in 
all the records in a file.</p>
<p>
</p>
<h2><a name="checking_for_errors">Checking for errors</a></h2>
<p>It is a good idea to get in the habit of checking for errors. MARC/Perl has 
been designed to help you do this. Calls to <code>next()</code> when iterating through a
batch file will return <code>undef</code> when there are no more records to
return...<strong>AND</strong> when an error was encountered. You probably want to make sure
that you didn't abruptly stop reading a batch file because of an error.</p>
<pre>
   1   ## Example 3 
   2   
   3   ## create a MARC::Batch object
   4   use MARC::Batch;
   5   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   6   
   7   ## get a marc record from the MARC::Batch object
   8   ## $record will be a MARC::Record object
   9   while ( my $record = $batch-&gt;next() ) {
  10       print $record-&gt;title();
  11   }
  12   
  13   ## make sure there weren't any problems 
  14   my @warnings = $batch-&gt;warnings();
  15   if ( @warnings ) {
  16       print &quot;we found some warnings!&quot;, join(&quot;\n&quot;,@warnings);
  17   }</pre>
<p>The call to <code>warnings()</code> at line 14 will retrieve any warning messages and store
them in the array @warnings. This allows you to detect when <code>next()</code> has 
aborted prematurely (before the end of the file has been reached).</p>
<p>
</p>
<h2><a name="recovering_from_errors">Recovering from errors</a></h2>
<p>You may want to keep reading a batch file even after an error has been
encountered.  If so you will want to turn strict mode off using the <code>strict_off()</code>
method. You can also prevent warnings from being printed to STDERR using the 
<code>warnings_off()</code> method.</p>
<pre>
   1   ## Example 4
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new( 'USMARC', 'file.dat' );
   5   $batch-&gt;strict_off();
   6   $batch-&gt;warnings_off();
   7   
   8   while ( my $record = $batch-&gt;next() ) {
   9      print $record-&gt;title();
  10   }</pre>
<p>Use of <code>strict_off()</code> allows you to continue reading after an error is 
encountered.  By default strict is on as a safety precaution to prevent you from
using corrupt MARC data.  Once off you can turn both strict and warnings back on
again with the <code>strict_on()</code> and <code>warnings_on()</code> methods.</p>
<p>
</p>
<h2><a name="looking_at_a_field">Looking at a field</a></h2>
<p>Examples 1.1 - 1.3 use MARC::Record's <code>title()</code> method to easily access the
245 field...but you probably will want to write programs that access lots
of other MARC fields.</p>
<p>MARC::Record's <code>field()</code> method gives you complete access the data 
found in any MARC field. The <code>field()</code> method returns a MARC::Field object
which can be used to access the data, indicators, and even the individual 
subfields. Example 1.4 shows you how this is done.</p>
<pre>
   1   ## Example 4
   2   
   3   ## open a file
   4   use MARC::Batch;
   5   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   6   
   7   ## read a record
   8   my $record = $batch-&gt;next();
   9   
  10   ## get the record's 100 field as a MARC::Field object
  11   my $field = $record-&gt;field('100'); 
  12   print &quot;The 100 field contains: &quot;,$field-&gt;as_string(),&quot;\n&quot;; 
  13   print &quot;The 1st indicator is &quot;,$field-&gt;indicator(1),&quot;\n&quot;;
  14   print &quot;The 2nd indicator is &quot;,$field-&gt;indicator(2),&quot;\n&quot;;
  15   print &quot;Subfield d contains: &quot;,$field-&gt;subfield('d'),&quot;\n&quot;;</pre>
<p>
</p>
<h2><a name="looking_at_repeatable_fields">Looking at repeatable fields</a></h2>
<p>So how do you retrieve data from repeatable fields? The <code>field()</code> method
can help you with this as well.  Above in example 1.4 on line 11 the 
<code>field()</code> method was used in a <em>scalar</em> context, since the result was being 
assigned to the variable $field.</p>
<p>However in a <em>list</em> context <code>field()</code> will return all the fields in the 
record of that particular type. For example:</p>
<pre>
   1   ## Example 5 
   2   
   3   use MARC::Batch;
   4   my $file = MARC::Batch-&gt;new('USMARC','file.dat');
   5   my $record = $batch-&gt;next();
   6   
   7   ## get all the 650 fields (list context)
   8   my @fields = $record-&gt;field('650');
   9   
  10   ## examine each 650 field and print it out
  11   foreach my $field (@fields) {
  12     print $field-&gt;as_string(),&quot;\n&quot;;
  13   }</pre>
<p>
</p>
<h2><a name="looking_at_a_set_of_related_fields">Looking at a set of related fields</a></h2>
<p><code>field()</code> also allows you to retrieve similar fields using '.' as a wildcard. 
For example, this functionality allows you to retrieve all the note fields
in one shot.</p>
<pre>
   1   ## Example 6
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   5   my $record = $batch-&gt;next();
   6   
   7   foreach my $field ($record-&gt;field('5..')) {
   8     print $field-&gt;tag(),' contains ',$field-&gt;as_string(),&quot;\n&quot;;
   9   }</pre>
<p>Notice the shorthand in line 7 which compacts lines 7-13 of Example 1.5. 
Instead of storing the fields in an array, the <code>field()</code> still returns a list
in the for loop. Line 8 uses the <code>tag()</code> method which returns the tag number
for a particular MARC field--which is useful when you aren't certain what
tag you are dealing with.</p>
<p>
</p>
<h2><a name="looking_at_all_the_fields_in_a_record">Looking at all the fields in a record</a></h2>
<p>The last example in this section illustrates how to retrieve <em>all</em> the fields
in a record using the <code>fields()</code> method.</p>
<pre>
   1   ## Example 7
   2   
   3   use MARC::Batch;
   4   my $file = MARC::Batch-&gt;new('USMARC','file.dat');
   5   my $record = $batch-&gt;next();
   6   
   7   ## get all of the fields useing the fields() method
   8   my @fields = $record-&gt;fields();
   9   
  10   ## print out the tag, the indicators and the field contents
  11   foreach my $field (@fields) {
  12     print 
  13       $field-&gt;tag(), &quot; &quot;, 
  14       $field-&gt;indicator(1),
  15       $field-&gt;indicator(2), &quot; &quot;,
  16       $field-&gt;as_string, &quot; &quot;,
  17       &quot;\n&quot;;
  18   }</pre>
<p>
</p>
<hr />
<h1><a name="creating">CREATING</a></h1>
<p>The examples in the section 1 covered how to read in existing USMARC data
in a file. Section 2 will show you how to create a MARC record from scratch.
The techniques in this section would allow you to write programs that 
create MARC records that could then be loaded into an online catalog, or
sent to a third party.</p>
<p>
</p>
<h2><a name="creating_a_record">Creating a record</a></h2>
<p>To create a record you need to:</p>
<ol>
<li></li>
Create a MARC::Record object.
<p></p>
<li></li>
Add a leader to the record.
<p></p>
<li></li>
Create MARC::Field objects for each field you want to have in the record.
<p></p>
<li></li>
Add each of the MARC::Field objects to the MARC::Record object.
<p></p></ol>
<p>For example:</p>
<pre>
   1   ## Example 8 
   2   
   3   ## create a MARC::Record object
   4   use MARC::Record;
   5   my $record = MARC::Record-&gt;new();
   6   
   7   ## add the leader to the record 
   8   $record-&gt;leader('00903pam   2200265 a 4500');
   9   
  10   ## create an author field 
  11   my $author = MARC::Field-&gt;new(
  12     '100',1,'',
  13       a =&gt; 'Logan, Robert K.',
  14       d =&gt; '1939-'
  15     );
  16   $record-&gt;append_fields($author);
  17   
  18   ## create a title field
  19   my $title = MARC::Field-&gt;new(
  20     '245','1','4',
  21       a =&gt; 'The alphabet effect /',
  22       c =&gt; 'Robert K. Logan.'
  23     );
  24   $record-&gt;append_fields($title);</pre>
<p>The key to creating records from scratch is to use the <code>append_fields()</code>
method, which adds a field to the end of the record. Since each
field gets added at the end it's up to you to order the fields the 
way you want. <code>insert_fields_before()</code> and <code>insert_fields_after()</code> are similar
methods that allow you to define where the field gets added. These methods
are covered in more detail below.</p>
<p>
</p>
<h2><a name="creating_a_record_from_raw_marc_data_in_a_variable">Creating a record from raw MARC data in a variable</a></h2>
<p>The above examples illustrated how to create a record from MARC data stored
on disk. However you may have the raw USMARC data stored in a variable and 
want to create a MARC::Record from it. This situation can arise when you
are able to pull the MARC data out of a database, or using some input method
other that the filesystem. If you ever find yourself in this position take
a look at MARC::Record's <code>new_from_usmarc()</code> method which allows you to create
a MARC::Record object from the USMARC data stored in a variable.</p>
<p>
</p>
<hr />
<h1><a name="writing">WRITING</a></h1>
<p>Sections 1 and 2 showed how to read and create USMARC data. Once you know how 
to read and create it becomes important to know how to write the USMARC data 
to disk in order to save your work. In this example we will create 
a new record and save it to a file called 'record.dat'.</p>
<p>
</p>
<h2><a name="writing_records_to_a_file">Writing records to a file</a></h2>
<pre>
   1   ## Example 9 
   2   
   3   ## create MARC object
   4   use MARC::Record;
   5   my $record = MARC::Record-&gt;new();
   6   $record-&gt;leader('00903pam  2200265 a 4500');
   7   my $author = MARC::Field-&gt;new('100','1','', 
   8      a=&gt;'Logan, Robert K.', d=&gt;'1939-'
   9      );
  10   my $title = MARC::Field-&gt;new('245','1','4', 
  11      a=&gt;'The alphabet effect /', c=&gt;'Robert K. Logan.'
  12      );
  13   $record-&gt;append_fields($author,$title);
  14   
  15   ## open a filehandle to write to 'file.dat'
  16   open(OUTPUT, '&gt; record.dat');
  17   print OUTPUT $record-&gt;as_usmarc();
  18   close(OUTPUT);</pre>
<p>The <code>as_usmarc()</code> method call at line 17 returns a scalar value which is the
raw USMARC data for $record. The raw data is then promptly printed to the 
OUTPUT file handle. If you want to output multiple records to a file you could 
simply repeat the process at line 17 for the additional records.</p>
<p>Note to the curious: the <code>as_usmarc()</code> method is actually an alias to the
MARC::File::USMARC::encode() method. Having separate <code>encode()</code> methods is
a design feature of the MARC class hierarchy since it allows extensions to
be built that translate MARC::Record objects into different data formats.</p>
<p>
</p>
<h2><a name="debugging_with_as_formatted()">Debugging with <code>as_formatted()</code></a></h2>
<p>Since raw USMARC data isn't very easy for humans to read, it is often useful 
to be able to see the contents of your MARC::Record object represented in a 
'pretty' way for debugging purposes. If you have MARC::Record object you'd
like to pretty-print use the <code>as_formatted()</code> method.</p>
<pre>
   1   ## Example 10
   2   
   3   ## create MARC object
   4   use MARC::Record;
   5   my $record = MARC::Record-&gt;new();
   6   $record-&gt;leader('00903pam  2200265 a 4500');
   7   $record-&gt;append_fields(
   8      MARC::Field-&gt;new('100','1','', 
   9         a=&gt;'Logan, Robert K.', d=&gt;'1939-'
  10         ),
  11      MARC::Field-&gt;new('245','1','4', 
  12         a=&gt;'The alphabet effect /', c=&gt;'Robert K. Logan.' 
  13         ),
  14      );
  15   
  16   ## pretty print the record
  17   print $record-&gt;as_formatted();</pre>
<p>Unlike example 9 this code will pretty print the contents of the 
newly created record to the screen. Notice on lines to how you can add
a list of new fields by creating MARC::Field objects within a call to 
append_fields().</p>
<p>
</p>
<h2><a name="debugging_with_marcdump()">Debugging with <code>marcdump()</code></a></h2>
<p>If you have written USMARC data to a file (as in example 9) and you would
like to verify that the data is stored correctly you can use the marcdump
command line utility that was installed when you installed the MARC::Record
package.</p>
<pre>
 % marcdump record.dat
 record.dat
 LDR 00122pam  2200049 a 4500
 100 1  _aLogan, Robert K.
        _d1939-
 245 14 _aThe alphabet effect /
        _cRobert K. Logan.</pre>
<pre>
  Recs  Errs Filename
 ----- ----- --------
     1     0 record.dat</pre>
<p>As you can see this command results in the record being pretty printed to 
your screen (STDOUT). It is useful for verifying your USMARC data after
it has been stored on disk. More details about debugging are found later
in VALIDATING.</p>
<p>
</p>
<hr />
<h1><a name="updating">UPDATING</a></h1>
<p>Now that you know how to read, write and create MARC data you have the
tools you need to update or edit exiting MARC data. Updating MARC 
data is a common task for library catalogers. Sometimes there are huge
amounts of records that need to be touched up...and while the touch ups are
very detail oriented they are also highly repetitive. Luckily computers
are tireless, and not very prone to error (assuming the programmer isn't).</p>
<p>When libraries receive large batches of MARC records for electronic text 
collections such as NetLibrary, Making of America, or microfiche sets such as 
Early American Imprints the records are often loaded into an online system,
and then the system is used to update the records. Unfortunately not all 
these systems are created equal, and catalogers have to spend a great deal
of time touching up each individual record. An alternative would be to 
process the records prior to import, and then once in the system the records 
would not need touching up. This scenario would save a great deal of time for 
the cataloger who would be liberated to spend their time doing original 
cataloging...which computers are notably bad at!</p>
<p>
</p>
<h2><a name="adding_a_field">Adding a field</a></h2>
<p>Imagine that you have a batch of records in a file called 'file.dat'
and that you would like to add a local note to (590) to each record and save
it as 'file_2.dat'.</p>
<pre>
   1   ## Example 11 
   2   
   3   ## create our MARC::Batch object
   4   use MARC::Batch;
   5   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   6   
   7   ## open a file handle to write to
   8   open(OUT,'&gt;new.dat');
   9   
  10   ## read in each record 
  11   while ( my $record = $batch-&gt;next() ) {
  12   
  13       ## add a 590 field
  14       $record-&gt;append_fields(
  15          MARC::Field-&gt;new('590','','',a=&gt;'Access provided by Enron.')
  16       );
  17     
  18     print OUT $record-&gt;as_usmarc();
  19   
  20   }
  21   
  22   close(OUT);</pre>
<p>Notice on lines 3-5 how MARC::Batch is used instead of MARC::File::USMARC. 
MARC::Batch provides an alternate way of reading records from files, and
provides a uniform interface to the different MARC::File modules.</p>
<p>
</p>
<h2><a name="preserving_field_order">Preserving field order</a></h2>
<p>As its name suggests <code>append_fields()</code> will add the 590 field to the end of
the record. If you want to preserve a particular order you can use the 
<code>insert_fields_before()</code> and insert_fields_after(). In order to use these you 
need to locate the field you want to insert before or after. Here is an 
example:</p>
<pre>
   1   ## Example 12
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   5   open(OUT,'&gt;new.dat');
   6   
   7   ## read in each record
   8   while ( my $record = $batch-&gt;next() ) {
   9   
  10       ## find the first tag after 590
  11       my $before;
  12       foreach ($record-&gt;fields()) {
  13           $before = $_;
  14           last if $_-&gt;tag() &gt; 590;
  15       } 
  16   
  17       ## create the 590 field
  18       my $new = 
  19           MARC::Field-&gt;new('590','','',a=&gt;'Access provided by Enron.');
  20   
  21       ## insert our 590 field 
  22       $record-&gt;insert_fields_before($before,$new);
  23   
  24       print OUT $record-&gt;as_usmarc();
  25   
  26   }</pre>
<p><code>insert_fields_after()</code> works in a simliar fashion to <code>insert_fields_before()</code>
but with the expected change of behavior.</p>
<p>
</p>
<h2><a name="deleting_a_field">Deleting a field</a></h2>
<p>You can also delete fields that you don't want. But you will want to check 
that the field contains what you expect before deleting it. Let's say Enron 
has gone out of busines and the 590 field needs to be deleted.</p>
<pre>
   1   ## Example 13 
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','new.dat');
   5   open(OUT,'&gt;newer.dat');
   6   
   7   while ( my $record = $batch-&gt;next() ) {
   8   
   9     ## get the 590 record
  10     my $field = $record-&gt;field('590');
  11   
  12     ## if there is a 590 field AND it has the word Enron in it
  13     if ($field and $field-&gt;as_string() =~ /Enron/i) {
  14   
  15       ## delete it!
  16       $record-&gt;delete_field($field);
  17   
  18     }
  19   
  20     ## output possibly modified record to our new file
  21     print OUT $record-&gt;as_usmarc(); 
  22   
  23   }</pre>
<p>The 590 field is retrieved on line 8; but notice how we check that we 
actually got a 590 field in $field, and that it contains the word 'Enron'
before we delete it. You need to pass <code>delete_field()</code> a MARC::Field
object that can be retrieved with the <code>field()</code> method.</p>
<p>
</p>
<h2><a name="changing_existing_fields">Changing existing fields</a></h2>
<p>Perhaps rather than adding or deleting a field you need to modify an 
existing field. This is achieved in several steps:</p>
<ol>
<li></li>
Read in the MARC record that you want to update.
<p></p>
<li></li>
Retrieve the field you want to update.
<p></p>
<li></li>
Call the field's <code>update()</code> method or <code>replace_with()</code> method to modify
the contents of the field.
<p></p>
<li></li>
Save the record.
<p></p></ol>
<p>Below is an example of updating any existing 590 field's containing the
word 'enron' to indicate that access is now provided through Arthur Andersen.</p>
<pre>
   1   ## Example 14
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','new.dat');
   5   open(OUT,'&gt;newer.dat');
   6   
   7   while ( my $record = $batch-&gt;next() ) {
   8   
   9     ## look for and a 590 field containing 'enron'
  10     my $field = $record-&gt;field('590');
  11     if ( $field and $field-&gt;as_string =~ /enron/i ) {
  12   
  13       ## create a new 590 field
  14       my $new_field = MARC::Field-&gt;new(
  15         '590','','',
  16           a =&gt; 'Access provided by Arthur Andersen.'
  17         );
  18   
  19       ## replace existing 590 field with the our new one
  20       $field-&gt;replace_with($new_field);
  21   
  22     }
  23   
  24     ## print out our (possibly) modified record
  25     print OUT $record-&gt;as_usmarc();
  26   
  27   }</pre>
<p>In this example we used MARC::Field's method <code>replace_with()</code> to replace
an existing field in the record with a new field that we created. To use 
<code>replace_with()</code> you need to retrieve the field you want to replace from
a MARC::Record object (line 7), create a new field to replace the existing
one with (lines 13-17), and then call the existing field's <code>replace_with()</code> 
method passing the new field as an argument (lines 19-20). You must pass
<code>replace_with()</code> a valid MARC::Field object for things to work.</p>
<p>
</p>
<h2><a name="updating_subfields_and_indicators">Updating subfields and indicators</a></h2>
<p>If you'd rather not replace an existing field with a new one, you can also 
edit the contents of the field itself using the <code>update()</code> method. Let's say 
you've got a batch of records and you want to make sure that the 2nd indicator 
for the 245 field is properly set for titles that begin with 'The'. The 2nd 
indicator should be '4' for titles beginning with 'The'.</p>
<pre>
   1   ## Example 15
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   5   open(OUT,'&gt;new.dat');
   6   
   7   while (my $record = $batch-&gt;next()) {
   8   
   9     ## retrieve the 245 record
  10     my $field_245 = $record-&gt;field('245');
  11   
  12     ## if we got the 245 and it starts with 'The'
  13     if ($field_245 and $field_245-&gt;as_string() =~ /^The /) {
  14   
  15       ## if the 2nd indicator isn't 4 we need to update
  16       if ($field_245-&gt;indicator(2) != 4) { 
  17        $field_245-&gt;update( ind2 =&gt; 4 );
  18       }
  19   
  20     }
  21   
  22     print OUT $record-&gt;as_usmarc();
  23   
  24   }</pre>
<p>The call to <code>update()</code> at line 17 sets the second indicator of the
existing 245 field to 4. In a simliar fashion you can also update individual
or multiple subfields.</p>
<pre>
  $field_245-&gt;update( a =&gt; 'History of the World :', b =&gt; 'part 1' );</pre>
<p>But beware, you can only update the first occurrence of a subfield using
update(). If you need to do more finer grained updates you are advised to
build a new field and replace the existing field with replace_with().</p>
<p>
</p>
<h2><a name="changing_a_record's_leader">Changing a record's leader</a></h2>
<p>This procedure works for fields, but editing the leader requires that you 
use the <code>leader()</code> method. When called with no arguments <code>leader()</code> will return
the current leader, and when you pass a scalar value as an argument the
leader will be set to this value. This example shows how you might want
to update position 6 of a records leader to reflect that the record is for
a computer file.</p>
<pre>
   1   ## Example 16
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   5   open(OUT,'&gt;new.dat');
   6   my $record = $batch-&gt;next();
   7   
   8   ## get the current leader
   9   my $leader = $record-&gt;leader();
  10   
  11   ## replace what is in position 6 with 'm'
  12   substr($leader,6,1) = 'm'; 
  13   
  14   ## update the leader
  15   $record-&gt;leader($leader);
  16   
  17   ## save the record to a file
  18   print OUT $record-&gt;as_usmarc();</pre>
<p>
</p>
<h2><a name="modifying_fields_without_indicators">Modifying fields without indicators</a></h2>
<p>MARC::Record and MARC::Field are smart and know that you don't have field
indicators with tags less than 010. Here's an example of updating/adding
an 005 field to indicate a new transaction time. For a little pizzazz we use 
Perl's <code>localtime()</code> to generate the data we need for this field.</p>
<pre>
   1   ## Example 17
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   5   open(OUT,'&gt;new.dat');
   6   
   7   while (my $record = $batch-&gt;next() ) {
   8   
   9     ## see if there is a 005 field 
  10     my $field_005 = $record-&gt;field('005');
  11   
  12     ## delete it if we found it
  13     $record-&gt;delete_field($field_005) if $field_005;
  14   
  15     ## figure out the contents of our new 005 field
  16     my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  17     $year += 1900;
  18     $mon += 1;
  19     my $datetime = sprintf(&quot;%4d%02d%02d%02d%02d%02d.0&quot;,
  20       $year,$mon,$mday,$hour,$min,$sec); 
  21     
  22     ## create a new 005 field using our new datetime
  23     $record-&gt;append_fields('005',$datetime);
  24   
  25     ## save record to a file
  26     print OUT $record-&gt;as_usmarc();
  27   
  28   }</pre>
<p>
</p>
<h2><a name="reordering_subfields">Reordering subfields</a></h2>
<p>You may find yourself in the situation where you would like to
programatically reorder, and possibly modify subfields in a particular
field. For example, imagine that you have a batch of records that have
856 fields which contain subfields z, u, and possibly subfield 3...
in any order! Now imagine that you'd like to standardize the subfield z, 
and reorder them so that subfield 3 precedes subfield z, which precedes 
subfield u. This is tricky but can be done in the following manner:</p>
<ol>
<li></li>
Read in a record
<p></p>
<li></li>
Extract the existing 856 field.
<p></p>
<li></li>
Build a new 856 field based on the existing field.
<p></p>
<li></li>
Replace the existing 856 field with the new one.
<p></p>
<li></li>
Save our modified record.
<p></p></ol>
<p>Here is the example in detail:</p>
<pre>
   1   ## Example 18
   2   
   3   use MARC::Batch;
   4   my $batch = MARC::Batch-&gt;new('USMARC','856.dat');
   5   open(OUT,'&gt;856_new.dat');
   6   
   7   while (my $record = $batch-&gt;next()) {
   8   
   9     my $existing = $record-&gt;field('856');
  10   
  11     ## make sure the record has an 856 field we can edit 
  12     if ($existing) { 
  13   
  14       ## now we're going to build a list of our new subfields (in order)
  15       my @subfields = ();
  16       
  17       ## if the 856 field has a subfield 3 add it
  18       if (defined($existing-&gt;subfield('3'))) {
  19         push(@subfields,'3',$existing-&gt;subfield('3'));
  20       }
  21       
  22       ## now add subfields z and u
  23       push(@subfields,'z','Access restricted',
  24         'u',$existing-&gt;subfield('u'));
  25       
  26       ## create a new 856 field using the new reordered subfields
  27       my $new = MARC::Field-&gt;new( 
  28         '856', $existing-&gt;indicator(1), $existing-&gt;indicator(2), @subfields
  29       );
  30       
  31       ## replace the existing subfield with our new one
  32       $existing-&gt;replace_with($new);
  33   
  34     }
  35       
  36     ## write out the record
  37     print OUT $record-&gt;as_usmarc();
  38   
  39   }</pre>
<p>
</p>
<hr />
<h1><a name="validating">VALIDATING</a></h1>
<p>The MARC::Record package has some extra goodies to allow you to validate 
records...MARC::Lint. MARC::Lint provides an extensive battery of tests,
and it also provides a framework for adding more.</p>
<p>
</p>
<h2><a name="using_marc::lint">Using MARC::Lint</a></h2>
<p>Here is an example of using MARC::Lint to generate a list of errors
present in a batch of records in a file named 'file.dat'.</p>
<pre>
   1   ## Example 19 
   2   
   3   use MARC::Batch;
   4   use MARC::Lint;
   5   
   6   my $batch = MARC::Batch-&gt;new('USMARC','file.dat');
   7   my $linter = MARC::Lint-&gt;new();
   8   my $counter = 0;
   9   
  10   while (my $record = $batch-&gt;next() ) {
  11   
  12     $counter++;
  13    
  14     ## feed the record to our linter object 
  15     $linter-&gt;check_record($record); 
  16   
  17     ## get the warnings
  18     my @warnings = $linter-&gt;warnings();
  19   
  20     ## output warnings (if any) with the record # 
  21     if (@warnings) {
  22   
  23       print &quot;RECORD $counter\n&quot;;
  24       print join(&quot;\n&quot;,@warnings),&quot;\n&quot;;
  25   
  26     }
  27   
  28   }</pre>
<p>MARC::Lint is quite thorough, and will check the following when validating:</p>
<ul>
<li></li>
Presence of 245 field.
<p></p>
<li></li>
Repeatability of fields.
<p></p>
<li></li>
Repeatability of subfields.
<p></p>
<li></li>
Valid use of subfield within particular fields.
<p></p>
<li></li>
Presence of indicators.
<p></p>
<li></li>
Indicator values.
<p></p></ul>
<p>
</p>
<h2><a name="customizing_marc::lint">Customizing MARC::Lint</a></h2>
<p>MARC::Lint makes no claim to check *everything* that might be wrong with 
a MARC record. In practice, individual libraries may have their own idea
about what is valid or invalid. For example a library may mandate that 
all MARC records with an 856 field should have a subfield z that reads
``Connect to this resource''.</p>
<p>MARC::Lint does provide a framework for adding rules. It can be done using
the object oriented programming technique of inheritance. In short you
can create your own subclass of MARC::Lint, and then use it to validate your
records. Here's an example:</p>
<pre>
   1   ## Example 20
   2   
   3   ## first, create our own subclass of MARC::Lint
   4   ## should be saved in a file called MyLint.pm
   5   
   6   package MyLint;
   7   use base qw(MARC::Lint);
   8   
   9   ## add a method to check that the 856 fields contain 
  10   ## a correct subfield z
  11   sub check_856 {
  12   
  13     ## your method is passed the MARC::Lint and MARC::Field objects
  14     my ($self,$field) = @_;
  15   
  16     if ($field-&gt;subfield('z') ne 'Connect to this resource') {
  17   
  18       ## add a warning to our lint object
  19       $self-&gt;warn(&quot;856 subfield z must read 'Connect to this resource'.&quot;);
  20   
  21     }
  22   
  23   }
  24    
  25</pre>
<pre>
   1   ## Then create a separate program that uses your subclass to validate
   2   ## NOTE: you need to make sure your program is able to find your 
   3   ## module MyLint.pm ... this can be achieved by putting both MyLint.pm 
   4   ## and this program in the same directory
   5   
   6   use MARC::Batch;
   7   use MyLint;
   8   
   9   my $linter = MyLint-&gt;new();
  10   my $batch = MARC::Batch-&gt;new('USMARC','file.marc');
  11   my $counter = 0;
  12   
  13   while (my $record = $batch-&gt;next()) {
  14   
  15     $counter++;
  16   
  17     ## check the record
  18     $linter-&gt;check_record($record);
  19   
  20     ## get the warnings, and print them out 
  21     my @warnings = $linter-&gt;warnings();
  22     if (@warnings) {
  23       print &quot;RECORD $counter\n&quot;;
  24       print join(&quot;\n&quot;,@warnings),&quot;\n&quot;;
  25     }
  26   
  27   }</pre>
<p>Notice how the call to <code>check_record()</code> at line 18 just above automatically 
calls the check_record in MARC::Lint. The property of inheritance is what
makes this happen. $linter is an instance of the MyLint class, and 
MyLint inherits from the MARC::Lint class, which allows $linter to inherit
all the functionality of a normal MARC::Lint object *plus* the new 
functionality found in the check_856 method.</p>
<p>Notice also that we don't have to call <code>check_856()</code> directy. The call to 
<code>check_record()</code> automatically looks for any check_XXX methods that it can
call to verify the record. Pretty neat stuff. If you've added validation
checks that you think could be of use to general public please share them
on the perl4lib listserv, or become a developer and add them to the source!</p>
<p>
</p>
<hr />
<h1><a name="swollen_appendices">SWOLLEN APPENDICES</a></h1>
<p>Brian Eno fans might catch this reference to his autobiography which was 
comprised of a years worth of diary entries plus extra topics at the end, and 
was entitled ``A Year With Swollen Appendices''. The following section is a grab 
bag group of appendices. Many of them are probably not filled in yet, this is 
because they are just ideas...so perhaps the appendices aren't that swollen 
yet. Feel free to suggest new ones, or to fill these in.</p>
<p>
</p>
<h2><a name="comparing_collections">Comparing Collections</a></h2>
<p>
</p>
<h2><a name="authority_records">Authority Records</a></h2>
<p>
</p>
<h2><a name="urls">URLs</a></h2>
<p>
</p>
<h2><a name="isbn/issns">ISBN/ISSNs</a></h2>
<p>
</p>
<h2><a name="call_numbers">Call numbers</a></h2>
<p>
</p>
<h2><a name="subject_headings">Subject headings</a></h2>
<p>Suppose you have a batch of MARC records and you want to extract all the
subject headings, and generate a report of how many times each subject
heading appeared in the batch.</p>
<pre>
   1   use MARC::File::USMARC;
   2   use constant MAX =&gt; 20;
   3   
   4   my %counts;
   5   
   6   my $filename = shift or die &quot;Must specify filename\n&quot;;
   7   my $file = MARC::File::USMARC-&gt;in( $filename );
   8   
   9   while ( my $marc = $file-&gt;next() ) {
  10       for my $field ( $marc-&gt;field(&quot;6..&quot;) ) {
  11           my $heading = $field-&gt;subfield('a');
  12   
  13           # Remove certain trailing whitespace and punctuation.
  14           $heading =~ s/[.,]?\s*$//;
  15   
  16           # Now count it
  17           ++$counts{$heading};
  18       }
  19   }
  20   $file-&gt;close();
  21   
  22   # Sort the list of headings based on the count of each.
  23   my @headings = reverse sort { $counts{$a} &lt;=&gt; $counts{$b} } keys %counts;
  24   
  25   # Take the top N hits.
  26   @headings = @headings[0..MAX-1];
  27   
  28   # Print out the results
  29   for my $heading ( @headings ) {
  30       printf( &quot;%5d %s\n&quot;, $counts{$heading}, $heading );
  31   }</pre>
<p>Which will generate results like this:</p>
<pre>
  600 United States
  140 World War, 1939-1945
   78 Great Britain
   63 Afro-Americans
   61 Indians of North America
   58 American poetry
   55 France
   53 West (U.S.)
   53 Science fiction
   53 American literature
   50 Shakespeare, William
   48 Soviet Union
   46 Mystery and detective stories
   45 Presidents
   43 China
   40 Frontier and pioneer life
   38 English poetry
   37 Authors, American
   37 English language
   35 Japan</pre>
<p>
</p>
<h2><a name="html">HTML</a></h2>
<p>
</p>
<h2><a name="xml">XML</a></h2>
<p>
</p>
<h2><a name="excel">Excel</a></h2>
<p>
</p>
<h2><a name="databases">Databases</a></h2>
<p>
</p>
<h2><a name="z39.50">Z39.50</a></h2>
<p>Chris Biemesderfer was kind enough to contribute a short example of how
to use MARC::Record in tandem with Net::Z3950.  Net::Z3950 is a CPAN
module which provides an easy to use interface to the Z39.50 protocol so that 
you can write programs that retrieve records from bibliographic database
around the world.</p>
<p>Chris' program is a command line utility which you can run like so:</p>
<pre>
  ./zm.pl 0596000278</pre>
<p>where 0596000278 is an ISBN (for the 3rd edition of the Camel incidentally).
The program will query the Library of Congress Z39.50 server for the ISBN, 
and dump out the retrieved MARC record on the screen. The program is designed
to lookup mutliple ISBNs if you separate them with a space.  This is just an 
example showing what is possible.</p>
<pre>
   1   #! /usr/bin/perl -w
   2  
   3   # GET-MARC-ISBN -- Get MARC records by ISBN from a Z39.50 server
   4  
   5   use strict;
   6   use Carp;
   7   use Net::Z3950;
   8   use MARC::Record;
   9  
  10   exit if ($#ARGV &lt; 0);
  11  
  12   # We handle multiple ISBNs in the same query by assembling a
  13   # (potentially very large) search string with Prefix Query Notation
  14   # that ORs the ISBN-bearing attributes.
  15   #
  16   # For purposes of automation, we want to request batches of many MARC
  17   # records.  I am not a Z39.50 weenie, though, and I don't know
  18   # offhand if there is a limit on how big a PQN query can be...
  19  
  20   my $zq = &quot;\@attr 1=7 &quot;. pop();
  21   while (@ARGV) { $zq = '@or @attr 1=7 '. pop() .&quot; $zq&quot; }
  22  
  23   ## HERE IS THE CODE FOR Z3950 REC RETRIEVAL
  24  
  25   # Set up connection management structures, connect to the server,
  26   # and submit the Z39.50 query.
  27  
  28   my $mgr = Net::Z3950::Manager-&gt;new( databaseName =&gt; 'voyager' );
  29   $mgr-&gt;option( elementSetName =&gt; &quot;f&quot; );
  30   $mgr-&gt;option( preferredRecordSyntax =&gt; Net::Z3950::RecordSyntax::USMARC );
  31  
  32   my $conn = $mgr-&gt;connect('z3950.loc.gov', '7090');
  33   croak &quot;Unable to connect to server $server&quot; if !defined($conn);
  34  
  35   my $rs = $conn-&gt;search($zq);
  36  
  37   my $numrec = $rs-&gt;size();
  38   print STDERR &quot;$numrec record(s) found\n&quot;;
  39  
  40   for (my $ii = 1; $ii &lt;= $numrec; $ii++) {
  41  
  42       # Extract MARC records from Z3950 result set, and load MARC::Record.
  43  
  44       my $zrec = $rs-&gt;record($ii);
  45       my $mrec = MARC::Record-&gt;new_from_usmarc($zrec-&gt;rawdata());
  46       print $mrec-&gt;as_formatted, &quot;\n\n&quot;;
  47  
  48   }</pre>
<p>
</p>
<h2><a name="procite/endnote">Procite/Endnote</a></h2>
<p>
</p>
<hr />
<h1><a name="contributors">CONTRIBUTORS</a></h1>
<p>Many thanks to all the contributors who have made this document possible.</p>
<ul>
<li></li>
Chris Biemesderfer &lt;<a href="mailto:chris@seagoat.com">chris@seagoat.com</a>&gt;
<p></p>
<li></li>
Andy Lester &lt;<a href="mailto:andy@petdance.com">andy@petdance.com</a>&gt;
<p></p>
<li></li>
Christopher Morgan &lt;<a href="mailto:morgan@acm.org">morgan@acm.org</a>&gt;
<p></p>
<li></li>
Jackie Shieh &lt;<a href="mailto:jshieh@umich.edu">jshieh@umich.edu</a>&gt;
<p></p>
<li></li>
Ed Summers &lt;<a href="mailto:ehs@pobox.com">ehs@pobox.com</a>&gt;
<p></p></ul>

</body>

</html>
